<div id="replace-content" style="text-align: left; margin: 25px;">
    <h2 class="title">Persistent Data Versus API</h2>
    <div class="post">
        
		<p>Let me just start out with a blanket fact, "I hate databases".  I don't particularly like having to save data, dealing with state is probably the most annoying aspect of software architecture, beating out even graphical user interfaces.  I am particularly fond of APIs and any well defined interfaces, using <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> to abstract away knowledge of any implementation details.  Interfaces let the software developer focus on the business logic and less on the infrastructure.  Nobody likes dealing with the non-value added part of any solution, or the "common task" especially when it is setting up infrastructure.</p>

		<p>So you want to write a service, or perhaps a website with dynamic content.  While doing so you will definitely run across various aspects or obsticles to delievring value.  A service has a defined business purpose, and best case scenario would be to choose a DSL (Domain Specific Language) to write your business logic and simply write your service in that DSL.  Without getting into the many issues about programming in different languages, each one has its benefits and disadvantages.  So you evaluate all the languages, and then choose the one that best allows the development of a solution in that space.  Maybe it is <a href="https://pages.github.com/">GitHub Pages</a> to host a website, or Facebook to host your physical event.  In the end you are choosing some engine and DSL to program, C++, a text editor, or website entry forms, and that is what matters to you.  It matters because your business logic is what you care about most, so being able to best describe it, allows you to provide as much value as possible.  What if the Facebook event system didn't allow to specify a location, would you still use that DSL, website, tool?  Maybe, but weighing the benefits would be a requirement.  How much effort would you be willing to expend to help design the system that would allow you to perfectly specify your business logic?  For me that is epsilon (quickly approaching zero).  The reason it is epsilon, is because there is no new software, everything has been done before.  What I need is a solution that perfectly matches my use case, but requires no more than my understanding.</p>

		<p>As an expert in software engineering, I think I can finally say that, I don't want to fight with the environment, DSL, or architecture to produce and program my business logic.  I am willing to take on just a little extra effort to make sure that I can deliver the maximum value, be it that effort to interface with other teams or add a new reference to an additional library.  When I want to interface with other solutions to help expand my options and reduce the infrastructure that are needed, APIs are must.  Historically the option of using another's database, or giving readonly access to yours seemed logical.  However, this results in many more problems than it solves.  Persistant data stores have one purpose, which is to be the place where my business logic saves its data.  It is not, nor it will ever be, additionally the interface to interact with other services.  There are many reasons for this.  For starters, having multiple teams or services using the same database couples these services to the same domain model.  This eliminates the elasticity needed for continual innovation.  Frequently, changes to databases are needed with changing requirements to business logic.  If services are coupled by a database, then every service using that database must change in sync, and thus multiple teams must work together to get this accomplished.  The more involved the effort, the less likely for it happen, and there bleads in <a href="https://en.wikipedia.org/wiki/Technical_debt">Tech Debt</a>.</p>

		<p>Fundamentally databases are not how the business logic is meant to be described*, the business logic is described in code, and so that is where the domain should be specified.  Putting the domain in the database, means that the domain is now in two places, the code and the persistence layer.  Separating the logic like that makes it difficult to maintain, which is why the usual solution is a database code generator.  Either a tool to generate code wrappers for interacting with the database or schema creation based on code.  These are bad tools, the tools themselves solve "A" problem, but not "The" problem.  The problem isn't how do I keep these in sync, it is "Why do I have to keep them in sync?".  Once the domain is represented by the database it needs to be validated.  Validation on a database is hardwork.  Database Schema are usually represented as "changes" rather than a "version", which makes validating the current version difficult unlike knowing which version of the source code is being used.  So let's get rid of that paradigm, by representing the whole domain in code, this is called code-first, and it generates lots of benefits.  For one it obfuscates the domain from a database perspective, and reminds viewers of that data that it is not meant to be interrogated directly, and second it guarantees that the whole of the business logic/domain model is one place.</p>

		<p>Ultimately, for a service to have value, it must save some sort of data.  That can be the code used to run the service, or persist runtime state.  The database is a great place to save state.  Let the database represent the way to save state, and leave the communicate and querying of the data to the APIs, that is what their purpose is.  Any other way, and it violates of the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>.</p>

		<p>Like with anything there may be dissent against using an API for this, questions may come back like "APIs are bad, they will get really big, how would we handle all the data people want" or "Versioning becomes a hard thing, isn't a database easier".  We must strive to reject these questions for they are no more than saying "I don't mind abusing the database and doing the wrong thing there, but when it comes to API's I have the need to do the right thing."  That's right APIs make you do the right thing; you can still do the wrong thing, it just becomes more difficult, and APIs expose these problems that have been present all along.  When that happens, it should be an obvious choice, pick the strategy which will expose problems, not hide them.</p>

		<p>*Database have been used for so long for this activity, that some have naturally grown to get better at this.  They still do it wrong, and that is why it is always difficult to do what you want easily.</p>
    </div>
</div>